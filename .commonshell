# -*- sh -*-
#

#################
### Variables ###
#################

UARCH=`uname -sm`
ARCH=`uname -m`
HOST=`hostname | sed 's/\..*//'`
ARCHBIN="$HOME/bin/`echo $UARCH| sed 's/ /\//'`"

SVN_EDITOR="emacs -nw --no-init-file --no-site-file"

export UARCH ARCH HOST ARCHBIN SVN_EDITOR

[[ -z "$REMOTEUSER" ]] && REMOTEUSER=$USER

###############
### Aliases ###
###############

alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'
alias l='ls -l -F --color'
alias ls='ls -F --color'
alias df='df -h'
alias jobs='jobs -p'
alias diff='colordiff'

alias classpath='echo $CLASSPATH | tr ":" "\n"'
alias cvsStat='cvs status 2>&1 | grep 'File:' | grep -v Up-to-date'
alias emacs='emacs --no-site-file'
alias pp='ps -u$USER -ww -o pid,etime,pcpu,rss,args'

alias axel='axel --num-connections=25 --alternate'
alias aria2c='aria2c --min-split-size=1M --max-connection-per-server=16 --split=25 --max-concurrent-downloads=25 --summary-interval=0 --truncate-console-readout=false --check-certificate=false'

alias mvn-mead-brms5='mvn -s ~/Work/maven-mead-brms5.xml -Dmaven.repo.local=$HOME/.m2-mead-brms5 -DaltDeploymentRepository=koji-repo::default::file://$HOME/tmp/deploy-mead-brms5 "$@"'
alias mvn-mead-brms6='mvn -s ~/Work/maven-mead-brms6.xml -Dmaven.repo.local=$HOME/.m2-mead-brms6 -DaltDeploymentRepository=koji-repo::default::file://$HOME/tmp/deploy-mead-brms6 "$@"'

#################
### Functions ###
#################

# Note - unset NO_LOCAL_OPTIONS from .zshrc as using LOCAL_OPTIONS in
# below functions to override .zshrc options temporarily. Also tried
# resetting zsh to known default using emulate -L zsh but my nested
# function calls don't work correctly then.

if [ "$SHELL" = "/bin/bash" ]
then
    # If we are a bash shell define noop function to work around zsh specific calls.
    function setopt ()
    {
        :
    }
fi

# If we are printing the environment (no arguments) print it sorted.
function env()
{
    if [ $# == 0 ]
    then
        /usr/bin/env | env "LC_ALL=C" sort
    else
        /usr/bin/env "$@"
    fi
}


# Note: while this does create a tunnel by default, it uses a different local port (18080)
# to avoid clashing with any local processes.
function ssh()
{
   if [ "$1" = "-l" ]
   then
       /usr/bin/ssh "$@"
   elif [ -n "`echo "$@" | grep www.jacorb.org`" ]
   then
       /usr/bin/ssh -X -Y -l cross "$@"
   else
       # Default to also creating a SSH tunnnel as well. Useful if we are doing smoke testing
       # and we need to see the admin console etc.
       /usr/bin/ssh -L18080:localhost:8080 -X -Y -l $REMOTEUSER "$@"
   fi
}

# Reverse based listing of last 10 entries. Useful for listing my downloads directory.
# Defaults to time based listing. Pass in args (e.g. -S for size based).
# Defaults to current directory. Pass in optional directory.
# lt [-S] [<dir>]
function lt()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    ARGS="-t"
    while [[ "$1" == -* ]] ; do
       ARGS="$1" ; shift
    done

    local TARGET=$1

    [[ -z "$TARGET" ]] && TARGET="."
    [[ ! -d "$TARGET" ]] && echo "Usage: lt <directory>" && return

    ls $ARGS -lr $TARGET 2>&1 | tail -10
}

function eclipse()
{
    (
        if [ "$KDE_FULL_SESSION" = "true" ]
        then
            # Override GTK settings for running in KDE - fixes a tooltip issue.
            export GTK2_RC_FILES=~/.gtkrc-2.0-eclipse
        fi
        /usr/local/eclipse/eclipse
    )
}

# Override for git to handle wrapping. I only want to use fmt for the log command.
function git()
{
   [[ -f /usr/local/bin/git ]] && local g=/usr/local/bin/git || local g=/usr/bin/git
   if [ "$1" = "clone" ]
   then
       $g "$@"
       echo -e "\033[49;32;1mRemember to set local email *if* required via 'git config user.email xxxx'\033[0m"
   elif [ "$1" = "interactivestash" ]
   then
       echo -e "\033[49;32;1mUsage:\n\ny - stash this hunk\nn - do not stash this hunk\nq - quit; do not stash this hunk nor any of the remaining ones\na - stash this hunk and all later hunks in the file\nd - do not stash this hunk nor any of the later hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\033[0m"
       $g "$@"
   # Was using hardcoded width of 108 for columns - now dynamic.
   elif [ "$1" = "lg" ]
   then
      $g -c core.pager="fmt -w `expr $COLUMNS + 25` -t | sed 's/^   /        /' | less -FrX" "$@"
   elif [ "$1" = "llg" ] || [ "$1" = "llg5" ]
   then
      $g -c  core.pager="fmt -w `expr $COLUMNS + 22` -t | sed 's/^   /        /' | less -FrX"  "$@"
   else
      $g -c core.pager="less -Fr" "$@"
   fi
}


# Show status of files
function gistat()
{
   setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

   local cpwd=$PWD REPO

   if [ -d $cpwd/.git ]
   then
      echo -e "\e[01;32m$cpwd\e[00m"
      if [ `git status -s | wc -l` = 0 ]
      then
         echo "   No changes or untracked files"
      else
         git status -s
      fi
   else
      # Lets recurse and look for one.
      for REPO in `find . -type d -name .git | sed 's/\.\/\(.*\)\/.git/\1/'`
      do
         cd $REPO
         echo -e "\e[01;32m$REPO\e[00m"
         if [ `git status -s | wc -l ` = 0 ]
         then
            echo "   No changes or untracked files"
         else
            git status -s
         fi
         cd $cpwd
      done
      cd $cpwd
   fi
}

# Recursive git implementation.
function rgit()
{
    (( $# == 0 )) && echo "Usage: $0 <git-cmd> ... [Run git command recursively over subdirs]" && return 1

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cwd=`pwd`

    for i in `find . -type d -name .git | env "LC_ALL=C" sort`
    do
        local d=`dirname $i | sed 's/\.\///'`
        echo -e "\033[49;32;1m### -> $d\033[0m"

        cd $d
        git "$@"
        cd $cwd
    done
}


# SVN Log implementation. It will print the log changes that are not in the local repository
# (or status message that we are up to date) and then print the last five local log entries.
# The problem occurs when we have mixed revisions in the working copy. It uses svnversion to
# try and establish the best point to do the log from.
function svnl()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cwd=`pwd`
    local log=5
    local textcol=32 # Green

    while [[ $1 == -* ]]
    do
        [[ "$1" = "-e" ]]  && textcol="33" && shift # Hidden externals call
        [[ "$1" = "-v" ]]  && verbose="-v" && shift
        [[ "$1" = "-l" && -n "$2" ]] && log="$2" && shift && shift
    done

    # last-changed-revision is the last changed under the current path. If svnl
    # is not being run at top level then this can produce curious results.
    #
    # Using the below command will give the overall revision of HEAD.
    # Combining this with svnversion will give a comparison between current point and HEAD.

    # From http://austinmatzko.com/2008/04/26/sed-multi-line-search-and-replace/
    local lastremoterev=`svn info -r HEAD 2> /dev/null | sed -rn '
    # if the first line copy the pattern to the hold buffer
    1h
    # if not the first line then append the pattern to the hold buffer
    1!H
    # if the last line then ...
    $ {
        # copy from the hold to the pattern buffer
        g
        # do the search and replace
        s/.*Revision: ([0-9]*).*/\1/
        # print
        p
    }'`
    [[ -z "$lastremoterev" ]] && echo "Not a svn repository" && return 1
    local revcheck=`svnversion .`

    if [ -n "`echo $revcheck | grep :`" ]
    then
        local subrange=`echo $revcheck | sed 's/.*:\([0-9]*\).*/\1/'`
        echo "Mixed revision working copy ($revcheck / range $subrange)"
    else
        local subrange=`echo $revcheck | sed 's/\([0-9]*\).*/\1/'`
    fi
    local EXTERNALS=`svn propget svn:externals -R | egrep '^[a-zA-Z]+' | head -1 | awk '{print $1"/"$3}'`

    if [ $subrange != $lastremoterev ]
    then
        # Print remote log between HEAD and working copy 'base head' ignoring the last '-' line
        # We add one so to get the difference between HEAD and local + 1
        svn log $verbose -r HEAD:$(($subrange+1)) "$@" | head --lines=-1
    else
        echo "[Up to date (rev: $revcheck)]"
    fi
    echo -e "\033[49;$textcol;1m========================================================================\033[0m"
    # Print local log ignoring the first '-' line
    svn log $verbose -l $log "$@" | tail --lines=+2

    # svn log doesn't cross into externals directories so recursively check them as well.
    if [ -n "$EXTERNALS" ]
    then
         echo -e "\033[49;$textcol;1mExternals detected ($EXTERNALS):\033[0m"
         cd $EXTERNALS
         svnl -e -l 3
    fi

    cd $cwd
}


function _java_prompt_()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$1" && "$1" != "sunjava5" && "$1" != "sunjava6" && "$1" != "sunjava7" \
        && "$1" != "ibmjava6"  && "$1" != "ibmjava7" ]] && echo "Private java setup function" && return

    local sunjava5=/usr/local/jdk1.5.0
    local sunjava6=/usr/local/jdk1.6.0
    local sunjava7=/usr/local/jdk1.7.0
    local ibmjava6=/usr/local/ibm-jdk1.6.0
    local ibmjava7=/usr/local/ibm-jdk1.7.0

    for i in $sunjava5 $sunjava6 $sunjava7 $ibmjava6 $ibmjava7
    do
        local replace="$i/bin:"
        PATH=`echo ${PATH//$replace/}`
    done

    case $1 in
      "sunjava5")
        export JAVA_HOME=$sunjava5
        ;;
      "sunjava6")
        export JAVA_HOME=$sunjava6
        ;;
      "sunjava7")
        export JAVA_HOME=$sunjava7
        ;;
      "ibmjava6")
        export JAVA_HOME=$ibmjava6
        ;;
      "ibmjava7")
        export JAVA_HOME=$ibmjava7
        ;;
    esac

    export PATH=$JAVA_HOME/bin:$PATH
}

function sunjava5()
{
    _java_prompt_ sunjava5

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(SUN5)%{"$'\e[00m''%}'
}

function sunjava6()
{
    _java_prompt_ sunjava6

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(SUN6)%{"$'\e[00m''%}'
}

function sunjava7()
{
    _java_prompt_ sunjava7

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(SUN7)%{"$'\e[00m''%}'
}

function ibmjava6()
{
    _java_prompt_ ibmjava6

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(IBM6)%{"$'\e[00m''%}'
}

function ibmjava7()
{
    _java_prompt_ ibmjava7

    PROMPT_JAVA="%{"$'\e[22;36m'"%}(IBM7)%{"$'\e[00m''%}'
}

function ant170()
{
    export ANT_HOME=/usr/local/apache-ant-1.7.0
    export PATH=$ANT_HOME/bin:$PATH

    alias ant='ant -logger org.apache.tools.ant.NoBannerLogger'
}

function maven()
{
    M2_HOME=/usr/share/maven
    echo "Maven home is $M2_HOME and mvn executable `which mvn`"
}

function unsignjar()
{
    [[ -z "$@" ]] && echo "Usage: unsignjar <jar> <jar>...." && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    for i in "$@"
    do
        if [ ! -f $i ]
        then
            echo "Unable to find $i"
        else
            local RESULT="`zip -v $i -d 'META-INF/*.RSA' | grep deleting`"
            local RESULT="`zip -v $i -d 'META-INF/*.SF' | grep deleting`"
            [[ -n $RESULT ]] && echo "$i: $RESULT"
        fi
    done
}

function checkSigning()
{
    [[ -z "$@" ]] && echo "Usage: checkSigning <pattern> <jars>[default to all]" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i

    if [ -z "$2" ]
    then
        JARS="`find . -name "*.jar"`"
    else
        JARS="$2"
    fi

    for i in `echo $JARS`
    do
        if [ -n "`jar tf $i | grep $1`" ]
        then
            echo $i

            jarsigner -verbose -certs -verify $i | grep --after-context=8 --max-count=1 "$1.*\.class"
            jar tvf $i | grep RSA

            echo "===================================================="
            echo ""
        fi
    done
}

function searchJars()
{
    [[ "$1" = "-v" ]] && local VERBOSE=true && shift
    [[ -z "$1" ]] && echo "Usage: searchJars <pattern>" && return

    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local i
    local pattern=`echo $1 | sed 's/\./\//g'`

    for i in `find . -name "*.jar"`
    do
        if [ -f $i ] && [ -n "`jar tf $i | grep $pattern`" ]
        then
            echo "Found pattern $pattern in $i"
            if [ "$VERBOSE" = "true" ]
            then
                echo "`jar vtf $i | grep $1 | sed 's/^/\t\t/g'`"
            fi
        fi
    done
}

function mvn-mead-hudson()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local TRUST_STORE=-Djavax.net.ssl.trustStore=$HOME/Work/jssecacerts
    local TRUST_STORE_PASSWORD=-Djavax.net.ssl.trustStorePassword=changeit
    local TRUST_STORE_TYPE=-Djavax.net.ssl.trustStoreType=jks
    local KEY_STORE=-Djavax.net.ssl.keyStore=$HOME/Work/jssecacerts
    local KEY_STORE_PASSWORD=-Djavax.net.ssl.keyStorePassword=changeit
    local KEY_STORE_TYPE=-Djavax.net.ssl.keyStoreType=jks
#    local DEBUG=-Djavax.net.debug=ssl:handshake:data

    local MAVEN_OPTS="$TRUST_STORE $KEY_STORE $TRUST_STORE_PASSWORD $KEY_STORE_PASSWORD $TRUST_STORE_TYPE $KEY_STORE_TYPE $DEBUG $MAVEN_OPTS"

    [[ `basename $PWD` == brms-p ]] && PROFILE="-Dsoa"

    mvn -s $HOME/Work/maven-hudson-mead-mirror.xml -DskipTests=true -Dmaven.repo.local=$HOME/.m2-mead-hudson -DaltDeploymentRepository=koji-repo::default::file://$HOME/tmp/deploy-mead-hudson $PROFILE "$@"
}

function ruby()
{
    [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"  # This loads RVM into a shell session.
}

# MAKE_MEAD - checkout of make_mead location.
# VMAN_HOME - checkout of vman.
function vman()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    [[ -z "$VMAN_HOME" ]] && echo "Set VMAN_HOME" && return 1

    if [ -n "$MAKE_MEAD" ]
    then
        local KEYSTORE=$MAKE_MEAD/jssecacerts
        local CERT="-Djavax.net.ssl.trustStore=${KEYSTORE} -Djavax.net.ssl.trustStorePassword=changeit -Djavax.net.ssl.trustStoreType=jks -Djavax.net.ssl.keyStore=${KEYSTORE} -Djavax.net.ssl.keyStorePassword=changeit -Djavax.net.ssl.keyStoreType=jks"
    else
        echo "MAKE_MEAD not set; not setting jssecacerts"
    fi
    #echo java `echo $CERT` -jar `/bin/ls $VMAN_HOME/target/pom-version-manipulator*-bin.jar` "$@"
    java `echo $CERT` -jar `/bin/ls $VMAN_HOME/target/pom-version-manipulator*-bin.jar` "$@"
}

#
# This script is sourced from
# https://community.jboss.org/blogs/stuartdouglas/2011/09/06/merging-github-pull-requests?_sscc=t
# and is designed to handle pull requests from github without leading to merges
# in the history (it does a rebase instead.
function mergePullRequest()
{
    setopt LOCAL_OPTIONS NO_ALL_EXPORT NO_AUTO_PUSHD

    local cmd="git fetch origin "
    local branch=`git rev-parse --abbrev-ref HEAD`

    for var in "$@"
    do
        cmd="$cmd pull/$var/head:pullRequest$var"
    done

    echo -e "\033[49;32;1m### -> Will merge pull request onto $branch\033[0m"

    echo "Running: '$cmd"
    eval $cmd

    for var in "$@"
    do
        echo "### Checking out pullRequest$var"
        git checkout pullRequest$var
        [[ "$?" != "0" ]] && echo "Error checking out branch; aborting..." && return 1
        echo "### Rebasing to $branch"
        git rebase $branch
        [[ "$?" != "0" ]] && echo "Error rebasing $branch; aborting..." && return 1
        echo "### Checking out $branch"
        git checkout $branch
        [[ "$?" != "0" ]] && echo "Error checking out $branch; aborting..." && return 1
        echo "### Merging pullRequest$var"
        git merge pullRequest$var
        [[ "$?" != "0" ]] && echo "Error merging pull request; aborting..." && return 1
        echo "### Deleting branch pullRequest$var"
        git branch -D pullRequest$var
        [[ "$?" != "0" ]] && echo "Error deleting branch; aborting..." && return 1
    done
    echo -e "\033[49;32;1mFinished\033[0m"
}
